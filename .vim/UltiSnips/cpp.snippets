snippet atcoder "Template for AtCoder" b
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <unordered_set>
#include <unordered_map>
#include <queue>
#include <string>
#include <cmath>
#include <numeric>
using namespace std;
typedef long long ll;
typedef pair<int, int> ii;
const int INF = 1 << 30;
const ll MOD = 998244353;
//const ll MOD = 1000000007;

int main() {
	$1
}
endsnippet

snippet inc "#include<>" b
#include <${1:iostream}>$2
endsnippet

snippet std "using namespace std;" b
using namespace std;
$1
endsnippet

snippet main "int main()" b
int main() {
	$1
}
endsnippet

snippet yorn "Output Yes or No" b
if (${1:flag}) cout << "Yes" << endl;
else cout << "No" << endl;
endsnippet

snippet Yorn "Output YES or NO" b
if (${1:flag}) cout << "YES" << endl;
else cout << "NO" << endl;
endsnippet

snippet if "if" b
if (${1:condition}) {
	$2
}
endsnippet

snippet if1 "if (condition) exp;" b
if (${1:condition}) $2;
endsnippet

snippet sort "sort(v.begin(), v.end())" b
sort(${1:v}.begin(), $1.end());
endsnippet

snippet sortr "sort(v.rbegin(), v.rend())" b
sort(${1:v}.rbegin(), $1.rend());
endsnippet

snippet for "for" b
for (${1:int i = 0}; ${2:i < N}; ${3:i++}) {
	$4
}
endsnippet

snippet fori "for (0, N)" b
for (int ${1:i} = 0; $1 < ${2:N}; $1++) {
	$3
}
endsnippet

snippet foreach "for x in X" b
for (auto ${1:x} : ${2:X}) {
	$3
}
endsnippet

snippet for1 "for [1, N]" b
for (int ${1:i} = 1; $1 <= ${2:N}; $1++) {
	$3
}
endsnippet

snippet while "while" b
while (${1:condition}) {
	$2
}
endsnippet

snippet def "function template" b
${1:int} ${2:func_name}(${3:void}) {
	$4
}
endsnippet

snippet struct "struct template" b
struct ${1:name} {
	$2
};
endsnippet

snippet cout "cout << " i
cout << $1
endsnippet

snippet cin "cin >> " b
cin >> $1
endsnippet

snippet vec "vector<T> v" i
vector<${1:int}> $2
endsnippet

snippet vi "vector<int>" i
vector<int> $1
endsnippet

snippet vll "vector<ll>" i
vector<ll> $1
endsnippet

snippet vc "vector<char>" i
vector<char> $1
endsnippet

snippet vs "vector<string>" i
vector<string> $1
endsnippet

snippet vii "vector<ii>" i
vector<ii> $1
endsnippet

snippet vvi "vector<vector<int>>" i
vector<vector<int>> $1
endsnippet

snippet vvll "vector<vector<ll>>" i
vector<vector<ll>> $1
endsnippet

snippet vvc "vector<vector<char>>" i
vector<vector<char>> $1
endsnippet

endsnippet
snippet vvec "vector<vector<T>>" i
vector<vector<${1:int}>> ${2:v}
endsnippet

snippet pair "pair<T, T>" i
pair<${1:int}, ${2:int}> $3
endsnippet

snippet map "map<Key, T>" i
map<${1:int}, ${2:int}> $3
endsnippet

snippet umap "unordered_map<Key, T>" i
unordered_map<${1:int}, ${2:int}> $3
endsnippet

snippet set "set<T>" i
set<${1:int}> $2
endsnippet

snippet uset "unordered_set" i
unordered_set<${1:int}> $2
endsnippet

snippet mset "multiset<T>" b
multiset<${1:int}> $2
endsnippet

snippet que "queue<T>" b
queue<${1:int}> ${2:que};
endsnippet

snippet stack "stack<T>" b
stack<${1:int}> ${2:st};
endsnippet

snippet deq "deque<T>" b
deque<${1:int}> ${2:deq};
endsnippet

snippet is_prime "judge if N is prime" b
bool is_prime(long long N) {
    if (N <= 1) return false;
    for (long long i = 2; i * i <= N; ++i) {
        if (N % i == 0) return false;
    }
    return true;
}
endsnippet

snippet enum_divisors "Enumerate the divisors of N" b
vector<long long> enum_divisors(long long N) {
    vector<long long> res;
    for (long long i = 1; i * i <= N; ++i) {
        if (N % i == 0) {
            res.push_back(i);
            if (N/i != i) res.push_back(N/i);
        }
    }
    sort(res.begin(), res.end());
    return res;
}
endsnippet

snippet prime_factorize "prime factorize" b
vector<pair<long long, long long> > prime_factorize(long long N) {
    vector<pair<long long, long long> > res;
    for (long long a = 2; a * a <= N; ++a) {
        if (N % a != 0) continue;
        long long ex = 0; // 指数

        while (N % a == 0) {
            ++ex;
            N /= a;
        }

        res.push_back({a, ex});
    }
    if (N != 1) res.push_back({N, 1});
    return res;
}
endsnippet

snippet legendre "count prime factors p in N!" b
long long legendre(long long n, long long p) {
    long long ret = 0;
    long long tmp = p;
    while (p <= n) {
        ret += n / p;
        p *= tmp;
    }
    return ret;
}
endsnippet

snippet Levenshtein "Levenshtein distance between S and T" b
int Levenshtein(string S, string T) {
    const int INF = 1 << 30; 
    vector<vector<int>> dp(S.size() + 1, vector<int>(T.size() + 1, INF));

    dp[0][0] = 0;

    for (int i = 0; i <= S.size(); ++i) {
        for (int j = 0; j <= T.size(); ++j) {
            if (i > 0 && j > 0) {
                if (S[i - 1] == T[j - 1]) {
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1]);
                }
                else {
                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1);
                }
            }
            
            if (i > 0) dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);

            if (j > 0) dp[i][j] = min(dp[i][j], dp[i][j - 1] + 1);
        }
    }
    
    return dp[S.size()][T.size()];
}
endsnippet

snippet LCS_len "length of LCS between S and T" b
int LCS_len(string S, string T) {
    int N = S.size(), M = T.size();
    vector dp(N + 1, vector<int>(M + 1, 0));
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= M; j++) {
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            if (S[i - 1] == T[j - 1]) {
                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1);
            }
        }
    }
    return dp[N][M];
}
endsnippet

snippet LCS_str "LCS between S and T" b
string LCS_str(string S, string T) {
    int N = S.size(), M = T.size();
    vector dp(N + 1, vector<int>(M + 1, 0));
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= M; j++) {
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            if (S[i - 1] == T[j - 1]) {
                dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + 1);
            }
        }
    }
    
    string res = "";
    int i = N, j = M;
    while (i > 0 & j > 0) {
        if (dp[i][j] == dp[i - 1][j]) {
            // (i-1, j) -> (i, j) と更新されていた場合
            i--;
        }    
        else if (dp[i][j] == dp[i][j - 1]) {
            // (i, j-1) -> (i, j) と更新されていた場合
            j--;
        }
        else {
             // (i-1, j-1) -> (i, j) と更新されていた場合
            res = S[i - 1] + res;
            i--; j--;
        }
    }
    
    return res;
}
endsnippet

snippet next_permutation "permutations in lexicographic order" b
sort(${1:v}.begin(), $1.end());
do {
    $2
}
while (next_permutation($1.begin(), $1.end()));
endsnippet

snippet binary_search "optimize with binary search" b
while (${1:r} - ${2:l} > 1) {
    long long m = ($1 + $2) / 2;
    if (P(m)) $1 = m;
    else $2 = m;
}
endsnippet

snippet bfs "bfs" b
vector<int> ${1:dist}(N, -1);
queue<int> que;

$1[0] = 0;
que.push(0);

while (!que.empty()) {
    int v = que.front();
    que.pop();

    for (int nv : ${2:G}[v]) {
        if ($1[nv] != -1) continue; 
        $1[nv] = $1[v] + 1;
        que.push(nv);
    }
}
endsnippet

snippet dfs "dfs with recursion" b
vector<bool> ${1:seen};
void dfs(const ${2:vector<vector<int> >} &G, int v) {
    $1[v] = true;

    for (auto next_v : G[v]) { 
        if ($1[next_v]) continue;
        dfs(G, next_v);
    }
}
endsnippet

snippet bipartite "return if G is a bipartite graph" b
void dfs(int v, vector<vector<int>> &G, vector<int> &color, bool &ans) {
    for(auto v2 : G[v]) {
        if(color[v2] != -1) {
            if(color[v2] == color[v]) {ans = false;}
            continue;
        }
        color[v2] = 1 - color[v];
        dfs(v2, G, color, ans);
    }
    return;
}

bool is_bipartite(vector<vector<int>> &G, int N) {
    bool ret = true;
    vector<int> color(N + 1, -1);
    for (int i = 1; i <= N; i++) {
        if (color[i] != -1) continue;
        color[i] = 0;
        dfs(i, G, color, ret);
    }
    return ret;
}
endsnippet
